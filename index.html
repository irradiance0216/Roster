<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Manning Pro: Logical Rotation v10</title>
    <style>
        :root { --primary: #2563eb; --work: #3b82f6; --break: #e2e8f0; --meal: #10b981; --text: #1e293b; }
        body { font-family: 'Inter', system-ui, sans-serif; background: #f1f5f9; color: var(--text); padding: 20px; }
        section { background: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); margin-bottom: 1.5rem; }
        
        .grid-inputs { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; align-items: end; }
        input { padding: 10px; border: 1px solid #cbd5e1; border-radius: 6px; width: 100%; box-sizing: border-box; }
        label { display: block; font-size: 11px; font-weight: 700; margin-bottom: 5px; text-transform: uppercase; color: #64748b; }
        
        .chart-container { overflow-x: auto; background: white; padding: 20px; border-radius: 12px; border: 1px solid #e2e8f0; }
        .schedule-grid { display: grid; grid-template-columns: 140px repeat(96, 45px); border-collapse: collapse; }
        .cell { height: 40px; border: 1px solid #f1f5f9; display: flex; align-items: center; justify-content: center; font-size: 10px; text-align: center; }
        .time-header { position: sticky; top: 0; background: white; font-weight: bold; z-index: 10; border-bottom: 2px solid #cbd5e1; }
        .worker-name { position: sticky; left: 0; background: #f8fafc; font-weight: bold; border-right: 2px solid #cbd5e1; z-index: 5; justify-content: flex-start; padding-left: 10px; }
        
        .status-work { background: var(--work); color: white; font-weight: bold; }
        .status-break { background: var(--break); color: #94a3b8; }
        .status-meal { background: var(--meal); color: white; font-weight: bold; }
        .status-off { background: #f8fafc; opacity: 0.4; }
        
        button { padding: 12px 20px; cursor: pointer; background: var(--primary); color: white; border: none; border-radius: 6px; font-weight: 700; width: 100%; margin: 10px 0; }
        .legend { display: flex; gap: 20px; margin-bottom: 15px; font-size: 13px; font-weight: 600; }
    </style>
</head>
<body>

    <section>
        <h2>Roster Setup</h2>
        <div class="grid-inputs">
            <div><label>Staff Name</label><input type="text" id="sName" placeholder="Name"></div>
            <div><label>Duty In</label><input type="time" id="sStart" value="09:00"></div>
            <div><label>Duty Out</label><input type="time" id="sEnd" value="17:00"></div>
            <button onclick="addStaff()">+ Add Staff</button>
        </div>
        <div id="staffList" style="margin-top:10px;"></div>
    </section>

    <section>
        <h2>Positions</h2>
        <div class="grid-inputs">
            <div><label>Position</label><input type="text" id="pName" placeholder="e.g. Counter"></div>
            <div><label>Start</label><input type="time" id="pStart"></div>
            <div><label>End</label><input type="time" id="pEnd"></div>
            <button onclick="addPosition()">+ Add Position</button>
        </div>
        <div id="pList" style="margin-top:10px;"></div>
    </section>

    <button onclick="runScheduler()">ðŸ”„ GENERATE LOGICAL SCHEDULE</button>

    <div class="legend">
        <div><span style="padding:2px 8px; background:var(--work); color:white">Work</span> (Min 1hr block)</div>
        <div><span style="padding:2px 8px; background:var(--meal); color:white">Meal Break</span> (Fixed 1hr)</div>
        <div><span style="padding:2px 8px; background:var(--break)">Short Break</span></div>
    </div>

    <div class="chart-container" id="chartOutput"></div>

    <script>
        let staff = JSON.parse(localStorage.getItem('staff_v10')) || [];
        let positions = JSON.parse(localStorage.getItem('positions_v10')) || [];
        
        const t2m = t => { const [h, m] = t.split(':').map(Number); return h * 60 + m; };
        const m2t = m => `${Math.floor(m/60).toString().padStart(2,'0')}:${(m%60).toString().padStart(2,'0')}`;

        function addStaff() {
            staff.push({ name: document.getElementById('sName').value, start: t2m(document.getElementById('sStart').value), end: t2m(document.getElementById('sEnd').value) });
            updateUI();
        }
        function addPosition() {
            positions.push({ name: document.getElementById('pName').value, start: t2m(document.getElementById('pStart').value), end: t2m(document.getElementById('pEnd').value) });
            updateUI();
        }
        function updateUI() {
            localStorage.setItem('staff_v10', JSON.stringify(staff));
            localStorage.setItem('positions_v10', JSON.stringify(positions));
            document.getElementById('staffList').innerHTML = staff.map((s,i)=>`<span>${s.name} <small onclick="staff.splice(${i},1);updateUI()">[x]</small> | </span>`).join('');
            document.getElementById('pList').innerHTML = positions.map((p,i)=>`<span>${p.name} <small onclick="positions.splice(${i},1);updateUI()">[x]</small> | </span>`).join('');
        }

        function runScheduler() {
            const container = document.getElementById('chartOutput');
            container.innerHTML = '';
            const grid = document.createElement('div');
            grid.className = 'schedule-grid';

            // Headers
            grid.appendChild(Object.assign(document.createElement('div'), { className: 'cell time-header', innerText: 'Staff' }));
            for(let m=0; m<1440; m+=15) {
                const h = grid.appendChild(document.createElement('div'));
                h.className = 'cell time-header';
                h.innerText = m % 60 === 0 ? m2t(m) : m%60;
            }

            // Initialize Staff States
            staff.forEach(s => {
                s.schedule = new Array(96).fill(null).map(() => ({ status: 'off', label: '' }));
                s.totalWork = 0;
                s.currentTask = null;
                s.taskTimer = 0; // How many 15m intervals they've been on current task
                s.hasHadMeal = false;
                s.mealTimer = 0; // Tracking meal progress
            });

            for (let i = 0; i < 96; i++) {
                const currentTime = i * 15;
                let activePos = positions.filter(p => currentTime >= p.start && currentTime < p.end);
                let onDuty = staff.filter(s => currentTime >= s.start && currentTime < s.end);

                // 1. Handle Ongoing Meals First
                onDuty.forEach(s => {
                    if (s.mealTimer > 0) {
                        s.schedule[i] = { status: 'meal', label: 'MEAL' };
                        s.mealTimer--;
                        if (s.mealTimer === 0) s.hasHadMeal = true;
                    } else {
                        s.schedule[i] = { status: 'break', label: 'â€”' };
                    }
                });

                // 2. Check if anyone NEEDS a meal (after 4 hours work and not currently tasked)
                onDuty.forEach(s => {
                    if (!s.hasHadMeal && s.mealTimer === 0 && s.totalWork >= 120 && s.taskTimer === 0) {
                        // Check if we have enough coverage to let them go
                        let othersOnDuty = onDuty.filter(o => o !== s && o.mealTimer === 0);
                        if (othersOnDuty.length >= activePos.length) {
                            s.schedule[i] = { status: 'meal', label: 'MEAL' };
                            s.mealTimer = 3; // 4 intervals total (including this one) = 60 mins
                            s.currentTask = null;
                            s.taskTimer = 0;
                        }
                    }
                });

                // 3. Keep People on their current task (Min 1 Hour Rule)
                activePos.forEach(pos => {
                    let workerStillOnPos = onDuty.find(s => s.currentTask === pos.name && s.taskTimer < 4 && s.mealTimer === 0);
                    if (workerStillOnPos) {
                        workerStillOnPos.schedule[i] = { status: 'work', label: pos.name };
                        workerStillOnPos.taskTimer++;
                        workerStillOnPos.totalWork += 15;
                        pos.filled = true;
                    } else {
                        pos.filled = false;
                    }
                });

                // 4. Assign remaining positions
                activePos.filter(p => !p.filled).forEach(pos => {
                    let candidates = onDuty.filter(s => 
                        s.schedule[i].status === 'break' && 
                        s.mealTimer === 0
                    );
                    
                    if (candidates.length > 0) {
                        // Sort by least total work
                        candidates.sort((a, b) => a.totalWork - b.totalWork);
                        let winner = candidates[0];
                        winner.schedule[i] = { status: 'work', label: pos.name };
                        winner.currentTask = pos.name;
                        winner.taskTimer = 1;
                        winner.totalWork += 15;
                    }
                });

                // 5. Reset task timers for people whose task just ended or they hit the 1hr mark and can be rotated
                onDuty.forEach(s => {
                    if (s.schedule[i].status === 'break') {
                        s.currentTask = null;
                        s.taskTimer = 0;
                    } else if (s.taskTimer >= 4) {
                        // Task timer resets if they are allowed to be swapped in next interval
                        s.taskTimer = 0; 
                    }
                });
            }

            // Render
            staff.forEach(s => {
                const nameDiv = document.createElement('div');
                nameDiv.className = 'cell worker-name';
                nameDiv.innerText = s.name;
                grid.appendChild(nameDiv);

                s.schedule.forEach(slot => {
                    const c = document.createElement('div');
                    c.className = `cell status-${slot.status}`;
                    c.innerText = slot.label;
                    grid.appendChild(c);
                });
            });

            container.appendChild(grid);
        }
        updateUI();
    </script>
</body>
</html>
